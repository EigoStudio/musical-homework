<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Spring Song Word Search</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Comic+Neue:wght@700&family=Kosugi+Maru&family=Nunito:wght@400;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --primary: #4a90e2; --secondary: #ff9500; --success: #34c759;
      --marker-h: rgba(255, 255, 0, 0.6); --marker-v: rgba(255, 105, 180, 0.5);
      --correct: rgba(52, 199, 89, 0.4); 
      --cell-size: 55px; 
      --board-width: 550px; 
    }
    body { font-family: 'Kosugi Maru', 'Nunito', sans-serif; margin: 0; display: flex; flex-direction: column; align-items: center; background-color: #fcfcfc; padding-bottom: 80px; touch-action: pan-y; overflow-x: hidden; }
    h1 { font-size: 26px; margin-top: 20px; margin-bottom: 40px; font-weight: 700; color: var(--primary); border-bottom: 2px solid var(--primary); }
    
    .controls { position: fixed; top: 10px; left: 10px; display: flex; flex-direction: column; gap: 5px; z-index: 100; }
    button { padding: 8px 15px; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; background: var(--primary); color: white; font-size: 12px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
    
    #board { display: grid; grid-template-columns: repeat(10, var(--cell-size)); gap: 0; width: var(--board-width); margin-bottom: 25px; background-color: #fff; touch-action: none; user-select: none; isolation: isolate; border: none; }
    .cell { width: var(--cell-size); height: var(--cell-size); line-height: var(--cell-size); font-size: 34px; text-align: center; font-weight: 700; font-family: 'Comic Neue', sans-serif; cursor: pointer; position: relative; pointer-events: auto; }
    .cell::after, .cell::before { content: ""; position: absolute; z-index: -1; mix-blend-mode: multiply; display: none; }
    .cell.h::after { display: block; left: 0; right: 0; top: 18%; bottom: 18%; background-color: var(--marker-h); }
    .cell.v::before { display: block; left: 18%; right: 18%; top: 0; bottom: 0; background-color: var(--marker-v); }
    .cell.h-start::after { border-top-left-radius: 28px; border-bottom-left-radius: 28px; border-left: 6px solid transparent; background-clip: padding-box; }
    .cell.h-end::after { border-top-right-radius: 28px; border-bottom-right-radius: 28px; border-right: 6px solid transparent; background-clip: padding-box; }
    .cell.v-start::before { border-top-left-radius: 28px; border-top-right-radius: 28px; border-top: 6px solid transparent; background-clip: padding-box; }
    .cell.v-end::before { border-bottom-left-radius: 28px; border-bottom-right-radius: 28px; border-bottom: 6px solid transparent; background-clip: padding-box; }
    .cell.show-ans { background-color: var(--correct); border-radius: 50%; }
    
    #word-list { display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); width: var(--board-width); row-gap: 20px; margin-bottom: 30px; box-sizing: border-box; }
    .word-item { cursor: pointer; display: flex; align-items: center; line-height: 1.3; text-align: left; font-size: 24px; padding: 5px; touch-action: auto; }
    .word-item.checked { color: #ccc; text-decoration: line-through; }
    .ja-text { font-size: 16px; color: #777; margin-left: 10px; }

    #lyrics-container { width: var(--board-width); margin-top: 10px; }
    .lyrics { font-size: 18px; line-height: 2.2; color: #333; text-align: left; font-family: 'Nunito', sans-serif; padding-left: 0.5cm; }
    .blank { display: inline-block; min-width: 80px; border-bottom: 2px solid var(--primary); color: #ff4757; font-weight: bold; margin: 0 1px; padding: 0 3px; text-align: center; }
    .blank.hidden { color: transparent; }

    @media screen and (max-width: 600px) {
      :root { --cell-size: 9.2vw; --board-width: 92vw; }
      .cell { font-size: 6.5vw; }
      #word-list, #lyrics-container { width: 92vw; }
      .word-item { font-size: 20px; }
      .controls { top: auto; left: auto; bottom: 20px; right: 10px; flex-direction: column; align-items: flex-end; }
      button { padding: 10px 18px; font-size: 13px; }
    }

    @media print { 
      @page { size: A4; margin: 15mm 10mm 15mm 10mm; } 
      body { background-color: white; color: black; padding-bottom: 0; overflow: visible; }
      .controls, #lyrics-container { display: none !important; } 
      h1 { font-size: 32px !important; text-align: center; color: black !important; border-bottom: none !important; margin-top: 0 !important; margin-bottom: 50px !important; } 
      #board { margin: 0 auto 50px auto !important; width: 550px !important; border: none !important; }
      #word-list { margin: 0 auto !important; width: 550px !important; row-gap: 20px !important; grid-template-columns: 260px 260px; }
      .word-item { font-size: 24px !important; color: black !important; text-decoration: none !important; }
      .ja-text { color: black !important; font-size: 16px !important; }
      .cell::after, .cell::before, .cell.show-ans { display: none !important; }
      .cell { color: black !important; font-size: 34px !important; width: 55px !important; height: 55px !important; }
    }
  </style>
</head>
<body>
  <div class="controls">
    <button onclick="initGame()">パズルをシャッフル</button>
    <button id="ans-btn" onclick="toggleAnswers()" style="background: var(--secondary);">答えを表示</button>
    <button onclick="window.print()" style="background: var(--success);">PDF保存 / 印刷</button>
  </div>

  <h1>Spring Song Word Search</h1>

  <div id="board"></div>
  <div id="word-list"></div>

  <div id="lyrics-container">
    <div class="lyrics">
        <span class="blank hidden" data-word="spring">Spring</span> is <span class="blank hidden" data-word="here">here</span>!<br>
        <span class="blank hidden" data-word="hello">Hello</span>! <span class="blank hidden" data-word="hello">Hello</span>! <span class="blank hidden" data-word="hello">Hello</span>!<br>
        <span class="blank hidden" data-word="warm">Warm</span> days are here.<br>
        Let's <span class="blank hidden" data-word="play">play</span> <span class="blank hidden" data-word="outside">outside</span>.<br>
        Come and <span class="blank hidden" data-word="play">play</span> with us.<br>
        <span class="blank hidden" data-word="everybody">Everybody</span>, come <span class="blank hidden" data-word="outside">outside</span>!<br>
        I can't wait to have a <span class="blank hidden" data-word="picnic">picnic</span><br>
        Underneath the <span class="blank hidden" data-word="cherry">cherry</span> <span class="blank hidden" data-word="blossoms">blossoms</span>.
    </div>
  </div>

  <script>
    const wordsData = [
      { en: "spring", ja: "春" }, { en: "here", ja: "ここ" },
      { en: "warm", ja: "暖かい" }, { en: "play", ja: "遊ぶ" },
      { en: "outside", ja: "外" }, { en: "everybody", ja: "みんな" },
      { en: "picnic", ja: "ピクニック" }, { en: "hello", ja: "こんにちは" },
      { en: "cherry", ja: "桜" }, { en: "blossoms", ja: "花" }
    ];

    const boardSize = 10;
    let grid = [];
    let answerCells = new Set();
    let isDragging = false, dragType = null, startR = null, startC = null, isEraserMode = false;

    function initGame() {
      const board = document.getElementById("board");
      const wordListDiv = document.getElementById("word-list");
      board.innerHTML = ""; wordListDiv.innerHTML = ""; answerCells.clear();
      document.querySelectorAll('.blank').forEach(el => el.classList.add('hidden'));

      grid = Array.from({length: boardSize}, () => Array(boardSize).fill(''));
      let shuffledWords = [...wordsData].sort(() => Math.random() - 0.5);
      let sortedForPlacement = [...shuffledWords].sort((a, b) => b.en.length - a.en.length);
      
      sortedForPlacement.forEach((word) => {
        let placed = false; let attempts = 0; const wordStr = word.en.toLowerCase();
        while (!placed && attempts < 1000) {
          attempts++;
          let isH = Math.random() < 0.5;
          let r = Math.floor(Math.random() * (isH ? boardSize : (boardSize - wordStr.length + 1)));
          let c = Math.floor(Math.random() * (isH ? (boardSize - wordStr.length + 1) : boardSize));
          if (canPlaceInDirection(wordStr, r, c, isH)) {
            for (let i = 0; i < wordStr.length; i++) {
              let currR = isH ? r : r + i; let currC = isH ? c + i : c;
              grid[currR][currC] = wordStr[i];
              answerCells.add(`${currR}-${currC}`);
            }
            placed = true;
          }
        }
      });

      for(let i=0; i<boardSize; i++){
        for(let j=0; j<boardSize; j++){
          if(grid[i][j] === '') grid[i][j] = String.fromCharCode(97 + Math.floor(Math.random()*26));
        }
      }

      grid.forEach((row, r) => row.forEach((ch, c) => {
        const cell = document.createElement("div");
        cell.className = "cell"; cell.textContent = ch;
        cell.dataset.r = r; cell.dataset.c = c;
        cell.addEventListener('mousedown', (e) => { e.preventDefault(); onStart(r, c); });
        cell.addEventListener('mouseenter', () => { if(isDragging) onMove(r, c); });
        board.appendChild(cell);
      }));

      board.addEventListener('touchstart', (e) => {
        const touch = e.touches[0];
        const target = document.elementFromPoint(touch.clientX, touch.clientY);
        if (target && target.classList.contains('cell')) {
          onStart(parseInt(target.dataset.r), parseInt(target.dataset.c));
        }
        e.preventDefault();
      }, {passive: false});

      board.addEventListener('touchmove', (e) => {
        const touch = e.touches[0];
        const target = document.elementFromPoint(touch.clientX, touch.clientY);
        if (target && target.classList.contains('cell')) {
          onMove(parseInt(target.dataset.r), parseInt(target.dataset.c));
        }
        e.preventDefault();
      }, {passive: false});

      window.addEventListener('mouseup', onEnd);
      window.addEventListener('touchend', onEnd);

      shuffledWords.forEach(w => {
        const div = document.createElement("div"); 
        div.className = "word-item";
        div.innerHTML = `<span>□ ${w.en}<span class="ja-text">${w.ja}</span></span>`;
        div.onclick = () => {
          div.classList.toggle("checked");
          const isChecked = div.classList.contains("checked");
          document.querySelectorAll(`.blank[data-word="${w.en}"]`).forEach(el => {
            isChecked ? el.classList.remove('hidden') : el.classList.add('hidden');
          });
        };
        wordListDiv.appendChild(div);
      });
    }

    function onStart(r, c) {
      isDragging = true; startR = r; startC = c; dragType = null;
      const cell = document.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
      // 消しゴムモードの判定は維持
      if (cell.classList.contains('h')) { isEraserMode = true; dragType = 'h'; }
      else if (cell.classList.contains('v')) { isEraserMode = true; dragType = 'v'; }
      else { isEraserMode = false; }
    }

    function onMove(r, c) {
      if (!isDragging) return;
      if (dragType === null) {
        if (r !== startR) { dragType = 'v'; }
        else if (c !== startC) { dragType = 'h'; }
        else { return; } // まだ動いていない場合は何もしない
      }
      
      // 起点(startR, startC)のセルを、確定した方向(dragType)で塗りつぶす
      const startCell = document.querySelector(`.cell[data-r="${startR}"][data-c="${startC}"]`);
      if (startCell) {
        isEraserMode ? startCell.classList.remove(dragType) : startCell.classList.add(dragType);
      }

      // 現在のセルの塗りつぶし
      const targetR = (dragType === 'h') ? startR : r;
      const targetC = (dragType === 'v') ? startC : c;
      const cell = document.querySelector(`.cell[data-r="${targetR}"][data-c="${targetC}"]`);
      if (cell) {
        isEraserMode ? cell.classList.remove(dragType) : cell.classList.add(dragType);
      }
    }

    function onEnd() { isDragging = false; updateEdgeStyles(); }

    function canPlaceInDirection(str, r, c, isH) {
      for (let i = 0; i < str.length; i++) {
        let currR = isH ? r : r + i; let currC = isH ? c + i : c;
        if (grid[currR][currC] !== '' && grid[currR][currC] !== str[i]) return false;
      }
      return true;
    }

    function updateEdgeStyles() {
      document.querySelectorAll('.cell').forEach(cell => {
        cell.classList.remove('h-start', 'h-end', 'v-start', 'v-end');
        const r = parseInt(cell.dataset.r), c = parseInt(cell.dataset.c);
        if (cell.classList.contains('h')) {
          const prev = document.querySelector(`.cell[data-r="${r}"][data-c="${c-1}"]`);
          const next = document.querySelector(`.cell[data-r="${r}"][data-c="${c+1}"]`);
          if (!prev || !prev.classList.contains('h')) cell.classList.add('h-start');
          if (!next || !next.classList.contains('h')) cell.classList.add('h-end');
        }
        if (cell.classList.contains('v')) {
          const prev = document.querySelector(`.cell[data-r="${r-1}"][data-c="${c}"]`);
          const next = document.querySelector(`.cell[data-r="${r+1}"][data-c="${c}"]`);
          if (!prev || !prev.classList.contains('v')) cell.classList.add('v-start');
          if (!next || !next.classList.contains('v')) cell.classList.add('v-end');
        }
      });
    }

    function toggleAnswers() {
      const btn = document.getElementById("ans-btn");
      const isShowing = btn.textContent === "答えを隠す";
      btn.textContent = isShowing ? "答えを表示" : "答えを隠す";
      document.querySelectorAll(".word-item").forEach(div => isShowing ? div.classList.remove("checked") : div.classList.add("checked"));
      document.querySelectorAll('.blank').forEach(el => isShowing ? el.classList.add('hidden') : el.classList.remove('hidden'));
      document.querySelectorAll(".cell").forEach(cell => { 
        const pos = `${cell.dataset.r}-${cell.dataset.c}`;
        if (answerCells.has(pos)) cell.classList.toggle("show-ans", !isShowing); 
      });
    }
    window.onload = initGame;
  </script>
</body>
</html>